#!/usr/bin/env bpftrace
/*
 * Trace kube-proxy data plane latency using eBPF
 * Measures ipt_do_table (iptables) and nft_do_chain (nftables) execution time
 * 
 * Usage: sudo bpftrace trace-kubeproxy.bt
 */

BEGIN
{
    printf("====================================================\n");
    printf("  Kube-Proxy Data Plane Latency Tracer (eBPF)\n");
    printf("====================================================\n");
    printf("Tracing iptables (ipt_do_table) and nftables (nft_do_chain)...\n");
    printf("Press Ctrl-C to stop and show statistics.\n\n");
    
    @iptables_count = 0;
    @nftables_count = 0;
}

/* ========================================
 * IPTABLES MODE TRACING
 * ======================================== */

// Entry probe for ipt_do_table (iptables rule traversal)
kprobe:ipt_do_table
{
    @ipt_start[tid] = nsecs;
}

// Return probe for ipt_do_table
kretprobe:ipt_do_table
/@ipt_start[tid]/
{
    $duration_ns = nsecs - @ipt_start[tid];
    $duration_us = $duration_ns / 1000;
    
    // Histogram of latency in microseconds
    @ipt_latency_us = hist($duration_us);
    
    // Count total invocations
    @iptables_count++;
    
    // Track min/max/sum for statistics
    @ipt_min_us = min($duration_us);
    @ipt_max_us = max($duration_us);
    @ipt_sum_us = sum($duration_us);
    
    delete(@ipt_start[tid]);
}

/* ========================================
 * NFTABLES MODE TRACING
 * ======================================== */

// Entry probe for nft_do_chain (nftables rule traversal)
kprobe:nft_do_chain
{
    @nft_start[tid] = nsecs;
}

// Return probe for nft_do_chain
kretprobe:nft_do_chain
/@nft_start[tid]/
{
    $duration_ns = nsecs - @nft_start[tid];
    $duration_us = $duration_ns / 1000;
    
    // Histogram of latency in microseconds
    @nft_latency_us = hist($duration_us);
    
    // Count total invocations
    @nftables_count++;
    
    // Track min/max/sum for statistics
    @nft_min_us = min($duration_us);
    @nft_max_us = max($duration_us);
    @nft_sum_us = sum($duration_us);
    
    
    delete(@nft_start[tid]);
}

/* ========================================
 * PERIODIC STATISTICS (every 5 seconds)
 * ======================================== */

interval:s:5
{
    time("\n%H:%M:%S ");
    printf("Statistics:\n");
    
    if (@iptables_count > 0) {
        $ipt_avg = @ipt_sum_us / @iptables_count;
        printf("  [iptables] Count: %d, Min: %d us, Avg: %d us, Max: %d us\n",
               @iptables_count, @ipt_min_us, $ipt_avg, @ipt_max_us);
    }
    
    if (@nftables_count > 0) {
        $nft_avg = @nft_sum_us / @nftables_count;
        printf("  [nftables] Count: %d, Min: %d us, Avg: %d us, Max: %d us\n",
               @nftables_count, @nft_min_us, $nft_avg, @nft_max_us);
    }
    
    if (@iptables_count == 0 && @nftables_count == 0) {
        printf("  No packets traced yet. Ensure traffic is flowing to worker service.\n");
    }
}

/* ========================================
 * FINAL REPORT (on Ctrl-C)
 * ======================================== */

END
{
    printf("\n====================================================\n");
    printf("  FINAL REPORT\n");
    printf("====================================================\n\n");
    
    // IPTABLES RESULTS
    if (@iptables_count > 0) {
        $ipt_avg = @ipt_sum_us / @iptables_count;
        
        printf("--- IPTABLES MODE ---\n");
        printf("Total invocations: %d\n", @iptables_count);
        printf("\nBasic Statistics:\n");
        printf("  Min latency:    %d us\n", @ipt_min_us);
        printf("  Mean latency:   %d us\n", $ipt_avg);
        printf("  Max latency:    %d us\n", @ipt_max_us);
        
        printf("\nLatency Distribution (microseconds):\n");
        print(@ipt_latency_us);
        printf("\n");
    } else {
        printf("--- IPTABLES MODE ---\n");
        printf("No iptables traffic observed.\n\n");
    }
    
    // NFTABLES RESULTS
    if (@nftables_count > 0) {
        $nft_avg = @nft_sum_us / @nftables_count;
        
        printf("--- NFTABLES MODE ---\n");
        printf("Total invocations: %d\n", @nftables_count);
        printf("\nBasic Statistics:\n");
        printf("  Min latency:    %d us\n", @nft_min_us);
        printf("  Mean latency:   %d us\n", $nft_avg);
        printf("  Max latency:    %d us\n", @nft_max_us);
        
        printf("\nLatency Distribution (microseconds):\n");
        print(@nft_latency_us);
        printf("\n");
    } else {
        printf("--- NFTABLES MODE ---\n");
        printf("No nftables traffic observed.\n\n");
    }
    
    // ERROR MESSAGING
    if (@iptables_count == 0 && @nftables_count == 0) {
        printf("====================================================\n");
        printf("  WARNING: No traffic detected!\n");
        printf("====================================================\n");
        printf("\nPossible reasons:\n");
        printf("1. No traffic was flowing to Services during trace\n");
        printf("2. Kernel symbols missing - check: cat /proc/kallsyms | grep -E 'ipt_do_table|nft_do_chain'\n");
        printf("3. pktgen not sending packets to worker service\n");
        printf("4. Kube-proxy not processing traffic\n\n");
    }
    
    // COMPARISON
    if (@iptables_count > 0 && @nftables_count > 0) {
        printf("====================================================\n");
        printf("  WARNING: Both iptables and nftables traffic detected!\n");
        printf("====================================================\n");
        printf("This is unusual - kube-proxy should use only one mode.\n\n");
    }
    
    printf("====================================================\n");
    
    // Cleanup
    clear(@ipt_start);
    clear(@nft_start);
    clear(@ipt_latency_us);
    clear(@nft_latency_us);
    clear(@iptables_count);
    clear(@nftables_count);
    clear(@ipt_sum_us);
    clear(@ipt_sum_sq);
    clear(@ipt_min_us);
    clear(@ipt_max_us);
    clear(@nft_sum_us);
    clear(@nft_sum_sq);
    clear(@nft_min_us);
    clear(@nft_max_us);
}
