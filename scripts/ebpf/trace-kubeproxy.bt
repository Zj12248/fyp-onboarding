#!/usr/bin/env bpftrace
/*
 * Trace kube-proxy data plane latency (Clean Version)
 * - Interval: Shows INSTANTANEOUS latency (last 5s)
 * - End: Shows CUMULATIVE latency (entire run)
 */

BEGIN
{
    printf("==========================================================\n");
    printf(" Kube-Proxy Latency Tracer (eBPF)\n");
    printf("==========================================================\n");
    printf("Tracing... Press Ctrl-C to stop.\n\n");
    printf("%-10s | %-12s | %-10s | %-15s\n", "TIME", "PACKETS/5s", "AVG LATENCY", "MAX LATENCY");
    printf("----------------------------------------------------------\n");
    
    // Global Totals (For Final Report)
    @total_count = 0;
    @total_sum = 0;
    @total_max = 0;
    
    // Interval Stats (Reset every 5s)
    @int_count = 0;
    @int_sum = 0;
    @int_max = 0;
}

/* ========================================
 * PROBE LOGIC (Handles both iptables & nftables)
 * ======================================== */

// Unified function to process latency
// We use a macro-like approach by repeating logic since bpftrace functions are limited
// Logic: 1. Calc Duration, 2. Update Interval, 3. Update Total

kprobe:ipt_do_table   { @start[tid] = nsecs; }
kprobe:nft_do_chain   { @start[tid] = nsecs; }

kretprobe:ipt_do_table, kretprobe:nft_do_chain
/@start[tid]/
{
    $start = @start[tid];
    
    // 1. Safety Checks
    if ($start == 0) { return; }
    $dur_ns = nsecs - $start;
    $dur_us = $dur_ns / 1000;
    
    // Filter crazy outliers (>1s)
    if ($dur_us > 1000000) { delete(@start[tid]); return; }

    // 2. Cast to safe unsigned integer
    $safe_dur = (uint64)$dur_us;

    // 3. Update Interval Stats (Reset every 5s)
    @int_count++;
    @int_sum += $safe_dur;
    if ($safe_dur > @int_max) { @int_max = $safe_dur; }

    // 4. Update Total Stats (For Final Report)
    @total_count++;
    @total_sum += $safe_dur;
    if ($safe_dur > @total_max) { @total_max = $safe_dur; }
    
    // 5. Histogram (Keep for final report)
    @dist_latency = hist($safe_dur);

    delete(@start[tid]);
}

/* ========================================
 * LIVE REPORTING (Every 5s)
 * ======================================== */

interval:s:5
{
    // Check if we have data in this interval
    if (@int_count > 0) {
        $avg = @int_sum / @int_count;
        
        // Print standardized columns
        time("%H:%M:%S   ");
        printf("| %-12d | %-6d us  | %-6d us\n", 
               @int_count, $avg, @int_max);
    } else {
        time("%H:%M:%S   ");
        printf("| %-12s | %-10s | %-15s\n", "0", "-", "-");
    }

    // RESET Interval Stats
    clear(@int_count);
    clear(@int_sum);
    clear(@int_max);
}

/* ========================================
 * FINAL SUMMARY
 * ======================================== */

END
{
    printf("\n==========================================================\n");
    printf(" FINAL SUMMARY REPORT\n");
    printf("==========================================================\n");

    if (@total_count > 0) {
        $avg = @total_sum / @total_count;
        
        printf("Total Packets Traced:  %d\n", @total_count);
        printf("Average Latency:       %d us\n", $avg);
        printf("Maximum Latency:       %d us\n", @total_max);
        
        printf("\nLatency Distribution (Logarithmic):\n");
        print(@dist_latency);
    } else {
        printf("\nNo packets captured.\n");
    }
    
    // Clear all maps
    clear(@start); clear(@dist_latency);
    clear(@total_count); clear(@total_sum); clear(@total_max);
    clear(@int_count); clear(@int_sum); clear(@int_max);
}